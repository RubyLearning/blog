<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tricks on RubyLearning Blog</title>
    <link>http://rubylearning.com/blog/categories/tricks/</link>
    <description>Recent content in Tricks on RubyLearning Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 19 Jun 2013 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://rubylearning.com/blog/categories/tricks/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>How do I benchmark Ruby code?</title>
      <link>http://rubylearning.com/blog/2013/06/19/how-do-i-benchmark-ruby-code/</link>
      <pubDate>Wed, 19 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>http://rubylearning.com/blog/2013/06/19/how-do-i-benchmark-ruby-code/</guid>
      <description>

&lt;p&gt;This guest post is by Jesse Storimer. Hes the author of &lt;a href=&#34;http://www.jstorimer.com/products/working-with-unix-processes&#34;&gt;Working With Unix Processes&lt;/a&gt;,
a gentle introduction to Unix system programming for Ruby programmers.
Jesse has been programming Ruby since joining Shopify in 2008 and is
still going strong, always looking for a chance to dig lower down into
the stack. He lives way in the backwoods of southern Ontario, Canada
with his wife and two daughters. Jesse blogs at
&lt;a href=&#34;http://jstorimer.com/&#34;&gt;jstorimer.com&lt;/a&gt; and has authored a few &lt;a href=&#34;http://www.jstorimer.com/books&#34;&gt;other books&lt;/a&gt; for Ruby developers.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rubylearning.com/images/jessestorimer.jpg&#34; alt=&#34;Jesse Storimer&#34; /&gt;

&lt;strong&gt;S&lt;/strong&gt;o you&amp;rsquo;ve got some Ruby code and you want to make it faster. Maybe
youve already got a new implementation in mind, or maybe youre still
cooking that up. But how do you make &lt;em&gt;certain&lt;/em&gt; that your new
implementation is faster?&lt;/p&gt;

&lt;p&gt;Science, of course! Rubys standard library comes with a benchmarking
library fit for measuring the execution time of your Ruby code. The
&lt;code&gt;Benchmark&lt;/code&gt; module offers several different ways for you to benchmark
your code. I&amp;rsquo;ll take you through the different options and their use
cases.&lt;/p&gt;

&lt;h2 id=&#34;getting-started:a88b551e347b89fbc8c0ddb2dc31561e&#34;&gt;Getting started&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Benchmark&lt;/code&gt; module is in the standard library, so you don&amp;rsquo;t need to
install any gems to get it. Heres the &lt;a href=&#34;http://www.ruby-doc.org/stdlib-2.0/libdoc/benchmark/rdoc/Benchmark.html&#34;&gt;documentation from the standard library&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The simplest way to measure your Ruby code is with &lt;code&gt;Benchmark.measure&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;script src=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/01_code.rb?embed=t&#34;&gt;&lt;/script&gt;
&lt;a href=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/01_code.rb&#34;&gt;Code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This will return something that looks like this:&lt;/p&gt;

&lt;p&gt;&lt;script src=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/01_result.txt?embed=t&#34;&gt;&lt;/script&gt;
&lt;a href=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/01_result.txt&#34;&gt;Code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;With no context, these might look like magic numbers. Here&amp;rsquo;s what they
mean:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://rubylearning.com/images/benchmark-breakdown.jpg&#34; alt=&#34;Benchmark numbers breakdown&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;Generally, the number farthest to the right is the most important one.
It tells how long it actually took to perform the operation. If youre
curious about why the clock time is so high, the other numbers can help
you drill down to see if youre spending time in system functions or your
own code.&lt;/p&gt;

&lt;p&gt;Now that you know what those magic numbers mean, we can move on to the
core &lt;code&gt;Benchmark&lt;/code&gt; API. The truth is that I rarely use the &lt;code&gt;measure&lt;/code&gt;
method on its own. It only prints the benchmark for a single block of
code. The most common way to use &lt;code&gt;Benchmark&lt;/code&gt; is to compare the execution
time of different approaches to the same problem.&lt;/p&gt;

&lt;p&gt;Benchmark has some built-in methods for this exact purpose.&lt;/p&gt;

&lt;h2 id=&#34;benchmark-bm:a88b551e347b89fbc8c0ddb2dc31561e&#34;&gt;&lt;code&gt;Benchmark#bm&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;This method lets you define several blocks of code to benchmark, then
prints the results side-by-side in the same format you saw earlier.&lt;/p&gt;

&lt;p&gt;&lt;script src=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/02_code.rb?embed=t&#34;&gt;&lt;/script&gt;
&lt;a href=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/02_code.rb&#34;&gt;Code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This will print the following result:&lt;/p&gt;

&lt;p&gt;&lt;script src=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/02_result.txt?embed=t&#34;&gt;&lt;/script&gt;
&lt;a href=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/02_result.txt&#34;&gt;Code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Notice that this is the same format I outlined earlier, but now you have
little hints about each of the numbers.&lt;/p&gt;

&lt;p&gt;The core API here is this:&lt;/p&gt;

&lt;p&gt;&lt;script src=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/03_core_example.rb?embed=t&#34;&gt;&lt;/script&gt;
&lt;a href=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/03_core_example.rb&#34;&gt;Code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You call the &lt;code&gt;Benchmark#bm&lt;/code&gt; method passing a block. The block variable
is a special object provided by &lt;code&gt;Benchmark&lt;/code&gt;. It gives you a &lt;code&gt;report&lt;/code&gt;
method that you call with the block of code that you want to measure.
&lt;code&gt;Benchmark&lt;/code&gt; then runs both blocks of code and prints their execution
times side-by-side.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A note about iterations:&lt;/em&gt; Often, when doing benchmarks that test code
that executes very quickly, you need to do many iterations to see a
meaningful number. In this case, I did 100,000 iterations of each
variant just to get the execution time up to half a second so I could
grasp the difference.&lt;/p&gt;

&lt;h2 id=&#34;labels:a88b551e347b89fbc8c0ddb2dc31561e&#34;&gt;Labels&lt;/h2&gt;

&lt;p&gt;In that last benchmark, I buried some comments in the source that said
what each block of code was doing. Thats not so helpful when looking at
the results! &lt;code&gt;Benchmark&lt;/code&gt; allows you to pass in a label to the &lt;code&gt;report&lt;/code&gt;
method that will be printed along with the results.&lt;/p&gt;

&lt;p&gt;&lt;script src=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/f4c734192682d7576b3ff804bfbb1271a16ae250/2013/06/19/how-do-i-benchmark-ruby-code/04_benchmark_labels.rb?embed=t&#34;&gt;&lt;/script&gt;
&lt;a href=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/04_benchmark_labels.rb&#34;&gt;Code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ive now removed the comments describing the blocks and pass them in to
the &lt;code&gt;report&lt;/code&gt; method as an argument. Now the output describes itself:&lt;/p&gt;

&lt;p&gt;&lt;script src=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/04_benchmark_results_padding.txt?embed=t&#34;&gt;&lt;/script&gt;
&lt;a href=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/04_benchmark_results_padding.txt&#34;&gt;Code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s one more important change I made in that last example that may
have gone unnoticed. I passed &lt;code&gt;27&lt;/code&gt; as an argument to the &lt;code&gt;Benchmark.bm&lt;/code&gt;
method. This signifies how much padding the header labels should have in
the result output. If you pass labels to &lt;code&gt;report&lt;/code&gt;, but dont set this
value high enough, your output wont line up properly.&lt;/p&gt;

&lt;p&gt;Lets see an example with no argument passed to &lt;code&gt;Benchmark.bm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;script src=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/04_benchmark_results_no_padding.txt?embed=t&#34;&gt;&lt;/script&gt;
&lt;a href=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/04_benchmark_results_no_padding.txt&#34;&gt;Code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Thats certainly not right. Make sure you pass a value thats greater than
the length of your longest label. Thats the happy path.&lt;/p&gt;

&lt;h2 id=&#34;benchmark-bmbm:a88b551e347b89fbc8c0ddb2dc31561e&#34;&gt;Benchmark#bmbm&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Benchmark#bm&lt;/code&gt; you just saw is really the core of &lt;code&gt;Benchmark&lt;/code&gt;, but
theres one more method I should mention: &lt;code&gt;Benchmark#bmbm&lt;/code&gt;. Thats right
its the same method name, repeated twice.&lt;/p&gt;

&lt;p&gt;Sometimes, with a benchmark that creates a lot of objects, the results
start to get skewed because of interactions with Rubys memory allocation
or garbage collection routines. When creating a lot of objects, one
block may need to run garbage collector, while the other doesnt; or just
one block may get stuck with the cost of allocating more memory for Ruby
to use.&lt;/p&gt;

&lt;p&gt;In this case, the benchmark can produce unbalanced results. This is when
you want to use &lt;code&gt;Benchmark#bmbm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The method name is suitable because it actually benchmarks your blocks
of code twice. First, it runs the code as a ‘rehearsal to force any
initialization that needs to happen, then it forces the GC to run, then
it runs the benchmark again ‘for real. This ensures that the system is
fully initialized and the benchmark is fair.&lt;/p&gt;

&lt;p&gt;This last example benchmark allocates a lot of objects. When this runs
at the rehearsal stage, Ruby has to allocate more memory to make room
for all the objects. Then when the ‘real benchmark happens, the memory
is already available and just the actual implementation is tested.&lt;/p&gt;

&lt;p&gt;&lt;script src=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/05_benchmark_bmbm.rb?embed=t&#34;&gt;&lt;/script&gt;
&lt;a href=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/05_benchmark_bmbm.rb&#34;&gt;Code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;And here&amp;rsquo;s the result:&lt;/p&gt;

&lt;p&gt;&lt;script src=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/05_benchmark_bmbm_results.txt?embed=t&#34;&gt;&lt;/script&gt;
&lt;a href=&#34;https://bitbucket.org/teamrubylearning/rubylearning-code-snippets/src/c40eadba0e5256e0c5c27f538315222c2e5d290f/2013/06/19/how-do-i-benchmark-ruby-code/05_benchmark_bmbm_results.txt&#34;&gt;Code&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Notice the discrepancy between the rehearsal and the benchmark! Thanks
&lt;code&gt;bmbm&lt;/code&gt;!&lt;/p&gt;

&lt;h2 id=&#34;conclusion:a88b551e347b89fbc8c0ddb2dc31561e&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;When you want to try your hand at speeding up some of your Ruby code,
make sure that you measure, measure, measure to prove that your new
implementation is faster than the old one. This great little
benchmarking library ships with Ruby right in the standard library, so
theres no excuses!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;I hope you found this article valuable. Feel free to ask questions and
give feedback in the comments section of this post. Thanks!&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Clojure Tips from the Experts</title>
      <link>http://rubylearning.com/blog/2010/07/26/clojure-tips-from-the-experts/</link>
      <pubDate>Mon, 26 Jul 2010 00:00:00 +0000</pubDate>
      
      <guid>http://rubylearning.com/blog/2010/07/26/clojure-tips-from-the-experts/</guid>
      <description>

&lt;p&gt;RubyLearning wrote to a lot of experts, gathering their best tips on
Clojure. The tips are still coming in, but here are some to get you
started with. Feel free to add your own tips in the comments section or
send the same to &lt;strong&gt;satishtalim [at] gmail.com&lt;/strong&gt;. Enjoy!&lt;/p&gt;

&lt;h2 id=&#34;antonio-cangiano:8e2a8fa6113b13df9499ac52ecdd6e19&#34;&gt;Antonio Cangiano&lt;/h2&gt;

&lt;p&gt;Find him on &lt;a href=&#34;http://twitter.com/acangiano&#34;&gt;Twitter&lt;/a&gt;. His
&lt;a href=&#34;http://programmingzen.com/&#34;&gt;Blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When learning a new programming language, I find &lt;a href=&#34;http://projecteuler.net/&#34;&gt;Project
Euler&lt;/a&gt; to be an invaluable source of
self-contained, increasingly more challenging exercises. By solving
these mathematical problems in your language of choice, you’ll get some
degree of exposure and familiarity with that language before tackling
more complex, real world tasks.&lt;/p&gt;

&lt;p&gt;When you solve a problem, you gain access to a forum where you can
compare your implementation with those of other people who may have used
the same language as you, or a different one. Normally there is a
variety of common (and not so common) languages used by fellow
participants.&lt;/p&gt;

&lt;p&gt;Through the forum you’ll learn about more efficient algorithms and
clever tricks, but above all you’ll get to see different ways to solve
the same problem. It’s not hard to spot clean, concise, and idiomatic
implementations and as a result end up learning more about the language
you used.&lt;/p&gt;

&lt;p&gt;Unfortunately for Clojure beginners, the threads in the forum for many
of the initial problems were closed a long time ago. In practice, this
means that you can usually read solutions implemented in many
established programming languages, including Ruby and Haskell, but you
won’t find solutions in Clojure for most of the problems (Clojure is
after all much newer).&lt;/p&gt;

&lt;p&gt;Thankfully, &lt;a href=&#34;http://clojure-euler.wikispaces.com/&#34;&gt;a wiki&lt;/a&gt; which
collects many solutions in Clojure exists. If you solve the problems
first on your own, you can then use this resource to compare your
approach with those of other Clojure programmers. You may discover that
there is a better, more idiomatic way of solving a given problem.&lt;/p&gt;

&lt;p&gt;In short, use &lt;a href=&#34;http://projecteuler.net/&#34;&gt;Project Euler&lt;/a&gt; and the &lt;a href=&#34;http://clojure-euler.wikispaces.com/&#34;&gt;Clojure
Euler wiki&lt;/a&gt; if you want to get
some experience with Clojure’s syntax and fundamental concepts, which
you may have only read about in books or online tutorials.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;baishampayan-ghose:8e2a8fa6113b13df9499ac52ecdd6e19&#34;&gt;Baishampayan Ghose&lt;/h2&gt;

&lt;p&gt;Find him on &lt;a href=&#34;http://twitter.com/ghoseb&#34;&gt;Twitter&lt;/a&gt;. His
&lt;a href=&#34;http://github.com/ghoseb/&#34;&gt;GitHub&lt;/a&gt; a/c.&lt;/p&gt;

&lt;p&gt;It’s hard to pin point a few good tips because Clojure can do so many
things in very nice and ingenious ways, that it’s not even funny.
Anyway, here are a few:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tip #1&lt;/strong&gt;: Sort a map on multiple keys:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;;; Tip #1
;;; A vector of maps
(def some-maps [{:x 1 :y 2} {:x 2 :y 1} {:x 1 :y 4} {:x 2 :y 8}])

;;; Sort the maps first on :x and then on :y

(defn sort-maps-by
  &amp;quot;Sort a sequence of maps (ms) on multiple keys (ks)&amp;quot;
  [ms ks]
  (sort-by #(vec (map % ks)) ms))

;;; (sort-maps-by some-maps [:x :y])
;;; output&amp;gt; ({:x 1, :y 2} {:x 1, :y 4} {:x 2, :y 1} {:x 2, :y 8})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Tip #2&lt;/strong&gt;: When dealing with infinite sequences on the REPL, you can
set the number of items to be printed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;;;; Tip #2
;;; When you type something like (iterate inc 1) on the REPL (or any
;;; kind of infinite, lazy sequence) the REPL will try to evaluate the
;;; whole thing and will never finish. One way to print some parts of
;;; an infinite sequence on the REPL is to do this on the REPL and
;;; then try to print the sequence -
;;; (set! *print-length* 10)
;;; (iterate inc 1)
;;; Which will only print the first 10 items of the above infinite
;;; sequence -
;;; (1 2 3 4 5 6 7 8 9 10 ...)
;;; There is also *print-level* which can be used to determine how
;;; nested/recursive data-structures are printed on the REPL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Tip #3&lt;/strong&gt;: Use of the -&amp;gt; &amp;amp; -&amp;gt;&amp;gt; threading macros:&lt;/p&gt;

&lt;p&gt;The -&amp;gt; &amp;amp; -&amp;gt;&amp;gt; threading macros are very useful to sometimes untangle
nested function calls. The -&amp;gt; macro takes a bunch of ‘forms’ and
‘threads them’ into each other by inserting every form as the second
item of the next form and so on. So, (-&amp;gt;&amp;gt; a (b c) (d e f) (g h))
becomes (g (d (b a c) e f) h). -&amp;gt;&amp;gt; is similar but it puts the form as
the last item of the next form. (-&amp;gt;&amp;gt; a (b c) (d e f) (g h)) then
becomes (g h (d e f (b c a))).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(ns tips
  ;; requires clojure 1.2 if you are on 1.1.x, use this instead
  ;; (:require [clojure.contrib.duck-streams :as io])
  (:require [clojure.contrib.io :as io]))

;;; Tip #3
;;; Use of the -&amp;gt; &amp;amp; -&amp;gt;&amp;gt; threading macros.
(defn word-freq
  &amp;quot;Calculate a frequency map of words in a text file.&amp;quot;
  [f]
  (take 20 (-&amp;gt;&amp;gt; f
                io/read-lines
                (mapcat (fn [l] (map #(.toLowerCase %) (re-seq #&amp;quot;\w+&amp;quot; l))))
                (remove #{&amp;quot;the&amp;quot; &amp;quot;and&amp;quot; &amp;quot;of&amp;quot; &amp;quot;to&amp;quot; &amp;quot;a&amp;quot; &amp;quot;i&amp;quot; &amp;quot;it&amp;quot; &amp;quot;in&amp;quot; &amp;quot;or&amp;quot; &amp;quot;is&amp;quot;})
                (reduce #(assoc %1 %2 (inc (%1 %2 0))) {})
                (sort-by (comp - val)))))

;;; Run it like this (word-freq &amp;quot;/path/to/file.txt&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;brian-carper:8e2a8fa6113b13df9499ac52ecdd6e19&#34;&gt;Brian Carper&lt;/h2&gt;

&lt;p&gt;Find him on &lt;a href=&#34;http://twitter.com/BrianCarper&#34;&gt;Twitter&lt;/a&gt;. His
&lt;a href=&#34;http://briancarper.net/&#34;&gt;Blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;“Named” or “keyword” arguments for functions have some benefits over
positional arguments:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;You can specify arguments in any order.&lt;/li&gt;
&lt;li&gt;The arguments are named explicitly, resulting in less room for error
compared to positional arguments, where it’s easy to transpose two
arguments in the list.&lt;/li&gt;
&lt;li&gt;Your function can easily provide default argument values.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For a function that takes only one or two arguments, keyword arguments
might be overkill. But the benefits of keyword arguments quickly become
more apparent the more argumentss your function accepts.&lt;/p&gt;

&lt;p&gt;Clojure doesn’t have canonical support for keyword arguments. But there
are a couple of ways you can achieve the same result.&lt;/p&gt;

&lt;p&gt;The first is simply to force the user to pass a hash-map explicitly.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn named-args-1 [foo argmap]
 (println &amp;quot;foo:&amp;quot; foo
          &amp;quot;bar:&amp;quot; (:bar argmap 0)
          &amp;quot;baz:&amp;quot; (:baz argmap 0))
 (println &amp;quot;bar-given?&amp;quot; (contains? argmap :bar)
          &amp;quot;baz-given?&amp;quot; (contains? argmap :baz)))

user&amp;gt; (named-args-1 1 {:baz 2})
foo: 1 bar: 0 baz: 2
bar-given? false baz-given? true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But wrapping arguments in braces is arguably an unnecessary burden on
users of your code. A better way is to use destructuring to allow the
user to “flatten” the map:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn named-args-2 [foo &amp;amp; args]
 (let [argmap (apply hash-map args)
       {:keys [bar baz]
        :or   {bar 0 baz 0}} argmap]
   (println &amp;quot;foo:&amp;quot; foo
            &amp;quot;bar:&amp;quot; bar
            &amp;quot;baz:&amp;quot; baz)
   (println &amp;quot;bar-given?&amp;quot; (contains? argmap :bar)
            &amp;quot;baz-given?&amp;quot; (contains? argmap :baz))))

user&amp;gt; (named-args-2 1 :baz 2)
foo: 1 bar: 0 baz: 2
bar-given? false baz-given? true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is OK for the user, but verbose for the function-writer. And the
argument list for the function is specified as “args”, giving the user
no clue as to what keys are expected or legal.&lt;/p&gt;

&lt;p&gt;As of recent releases of Clojure, you can do the destructuring right in
the function’s argument list, leading to this version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn named-args-3 [foo &amp;amp; {:keys [bar baz]
                          :or   {bar 0 baz 0}
                          :as   argmap}]
 (println &amp;quot;foo:&amp;quot; foo
          &amp;quot;bar:&amp;quot; bar
          &amp;quot;baz:&amp;quot; baz)
 (println &amp;quot;bar-given?&amp;quot; (contains? argmap :bar)
          &amp;quot;baz-given?&amp;quot; (contains? argmap :baz)))

user&amp;gt; (named-args-3 1 :baz 2)
foo: 1 bar: 0 baz: 2
bar-given? false baz-given? true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It’s also possible to roll your own macro to do keyword arguments. See
&lt;strong&gt;clojure.contrib.def/defnk&lt;/strong&gt;, for example.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;craig-andera:8e2a8fa6113b13df9499ac52ecdd6e19&#34;&gt;Craig Andera&lt;/h2&gt;

&lt;p&gt;Find him on &lt;a href=&#34;http://twitter.com/craigandera&#34;&gt;Twitter&lt;/a&gt;. His
&lt;a href=&#34;http://www.pluralsight-training.net/community/blogs/craig/&#34;&gt;Blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I have two. The first one I stole from Mike Fogus: to use “,,,” as a
placeholder in the &lt;strong&gt;-&amp;gt;&lt;/strong&gt; and &lt;strong&gt;-&amp;gt;&amp;gt;&lt;/strong&gt; macros. Since commas are
whitespace, they can be used as markers to indicate how the expressions
flow through the threading macros. So, for instance, you can write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(-&amp;gt;&amp;gt;
 (iterate inc 1)
 (map #(* 5 %) ,,,)
 (filter odd? ,,,))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the commas indicate “the previous expression will be inserted here”.&lt;/p&gt;

&lt;p&gt;It’s not something you should put in production code, but I found it
enormously helpful in “getting” the -&amp;gt; and -&amp;gt;&amp;gt; macros. Honestly, I
only had to write it out this way once or twice before it clicked with
me and I stopped using the commas altogether.&lt;/p&gt;

&lt;p&gt;The other tip I have, has to do with understanding when to use &lt;strong&gt;map&lt;/strong&gt;,
&lt;strong&gt;filter&lt;/strong&gt;, and &lt;strong&gt;reduce&lt;/strong&gt;. These three functions are where an enormous
amount of Clojure’s power comes from, but I find that beginners (such as
myself) sometimes have a hard time selecting which one – or which
combination – to use. What I’ve found is that it’s helpful to think of
these in terms of what you *have* and what you *need*:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If you *have* a sequence of length n and you *need* a sequence
of length n, use &lt;strong&gt;map&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;If you *have* a sequence of length n and you *need* a shorter
sequence, use &lt;strong&gt;filter&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;If you *have* a sequence of length n and you *need* a scalar,
use &lt;strong&gt;reduce&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It seems pretty obvious when stated like that, but it has been helpful
to me on occasion when I start to get lost in how to express a
particular algorithm.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;meikel-brandmeyer:8e2a8fa6113b13df9499ac52ecdd6e19&#34;&gt;Meikel Brandmeyer&lt;/h2&gt;

&lt;p&gt;Find him on &lt;a href=&#34;http://twitter.com/kotarak&#34;&gt;Twitter&lt;/a&gt;. His &lt;a href=&#34;http://bitbucket.org/kotarak&#34;&gt;BitBucket
Id&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here is my tip on &lt;strong&gt;atoms&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Clojure provides a lot of facilities to tackle the complexity of
concurrent programming. But still you have to understand the semantics
of the underlying facilities. One of these are &lt;strong&gt;refs&lt;/strong&gt;, which allow
coordinated access to several different entities at once. However, their
use inflicts quite a bit of ceremony. You have to invoke the STM
machinery whenever you want to write to a &lt;strong&gt;ref&lt;/strong&gt; or want a consistent
snapshot of several &lt;strong&gt;refs&lt;/strong&gt;. Also your transaction is rolled back
should a surrounding transaction retry. This is not always what you
want.&lt;/p&gt;

&lt;p&gt;In such cases, it is interesting to use an &lt;strong&gt;atom&lt;/strong&gt;. They are cheaper in
terms of overhead and don’t interact with the STM. So the retry of a
surrounding transaction doesn’t affect them. However they are
uncoordinated: you can’t safely update multiple &lt;strong&gt;atoms&lt;/strong&gt; at once.&lt;/p&gt;

&lt;p&gt;What is not so well known, is the fact, that &lt;strong&gt;refs&lt;/strong&gt; also coordinate
several accesses to the *same* &lt;strong&gt;ref&lt;/strong&gt;. Again, this does *not* work
well with &lt;strong&gt;atoms&lt;/strong&gt;. Consider a cache, eg. for a &lt;strong&gt;memoized&lt;/strong&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn memoize
 [f]
 (let [cache (atom {})]
   (fn [&amp;amp; args]
     (when-not (contains? @cache args)
       (swap! cache assoc args (apply f args)))
     (get @cache args))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code uses an &lt;strong&gt;atom&lt;/strong&gt; and clojure datastructures, so we have no
problems with concurrency, right? &lt;strong&gt;Wrong!&lt;/strong&gt; There are plenty of race
conditions between the different calls to &lt;strong&gt;contains?&lt;/strong&gt;, &lt;strong&gt;swap!&lt;/strong&gt; and
&lt;strong&gt;get&lt;/strong&gt;. In the example, the worst thing that can happen is that we
compute the value of the function call several times. This can already
be quite annoying if the call is expensive in computation time and/or
resources. But consider a more involved cache implementation which could
also remove entries from the cache. Then the call to &lt;strong&gt;contains?&lt;/strong&gt; could
see the value, but when we call get it might already be removed.&lt;/p&gt;

&lt;p&gt;The problem is, that we access the atom’s contents several times and
this is not coordinated. Contrary to &lt;strong&gt;refs&lt;/strong&gt; where we could call ensure
to – well – ensure that the &lt;strong&gt;ref&lt;/strong&gt; doesn’t change under our hands.&lt;/p&gt;

&lt;p&gt;How to solve this problem? Well, the problem is that we touch the
&lt;strong&gt;atom&lt;/strong&gt; several times. So the solution is to touch the &lt;strong&gt;atom&lt;/strong&gt; only
once!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn memoize
 [f]
 (let [cache  (atom {})
       update (fn [state args]
                (if-not (contains? state args)
                  (assoc state args (apply f args))
                  state))]
   (fn [&amp;amp; args]
     (get (swap! cache update args) args))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we do the contains check and update in one function which will see
a consistent view of the cache state. Note that we also use the return
value of the &lt;strong&gt;swap!&lt;/strong&gt;. Otherwise we would again have to access to the
atom several times!&lt;/p&gt;

&lt;p&gt;So while Clojure provides a lot of tools to tackle the problems of a
concurrent world, you still have to understand what the semantics of the
different tools are. And even then you have to carefully reason about
your code. How it behaves. Where race conditions might hide. Life is not
easy.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: There are other problems to the above problem. Eg. doing
expensive work – namely calling f – in a &lt;strong&gt;swap!&lt;/strong&gt;. Please read
&lt;a href=&#34;http://kotka.de/blog/2010/03/memoize_done_right.html&#34;&gt;Meikel’s blog
post&lt;/a&gt; on
&lt;strong&gt;memoize&lt;/strong&gt; where even more such considerations are taken into account.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;michael-fogus:8e2a8fa6113b13df9499ac52ecdd6e19&#34;&gt;Michael Fogus&lt;/h2&gt;

&lt;p&gt;Find him on &lt;a href=&#34;http://twitter.com/fogus&#34;&gt;Twitter&lt;/a&gt;. His book &lt;a href=&#34;http://fogus.me/&#34;&gt;The Joy of
Clojure&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Many macros that I write start exactly the same way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   (defmacro a-macro [&amp;amp; forms]
     `&#39;~forms)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then it proceeds to be transformed into a pipeline where each piece does
a gradual transformation of forms:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   (defn do-something [forms]
     (frobnicate forms))

   (defn do-something-else [forms]
     (moidilize forms))

   (defmacro a-macro [&amp;amp; forms]
     (let [forms (do-something forms)
           forms (do-something-else forms)])
     `&#39;~forms)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This makes it easy to see the transformations occurring at each step,
keeps my macros small, and allows me to put error handling in each of
the transformation functions for compile-time exceptions.&lt;/p&gt;

&lt;p&gt;Although this is all pretty arcane as I try really really hard to avoid
writing macros else I get beaten.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;michael-kohl:8e2a8fa6113b13df9499ac52ecdd6e19&#34;&gt;Michael Kohl&lt;/h2&gt;

&lt;p&gt;Find him on &lt;a href=&#34;http://twitter.com/citizen428&#34;&gt;Twitter&lt;/a&gt;. His
&lt;a href=&#34;http://citizen428.net/&#34;&gt;Blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My tip would be the &lt;a href=&#34;http://clojure.org/reader&#34;&gt;Clojure reader macro
&lt;strong&gt;#_&lt;/strong&gt;&lt;/a&gt; which completely ignores the next
form. From the docs:&lt;/p&gt;

&lt;p&gt;“The form following &lt;strong&gt;#_&lt;/strong&gt; is completely skipped by the reader. (This
is a more complete removal than the &lt;strong&gt;comment&lt;/strong&gt; macro which yields
&lt;strong&gt;nil&lt;/strong&gt;).”&lt;/p&gt;

&lt;p&gt;This can be immensely useful while debugging.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;nurullah-akkaya:8e2a8fa6113b13df9499ac52ecdd6e19&#34;&gt;Nurullah Akkaya&lt;/h2&gt;

&lt;p&gt;Find him on &lt;a href=&#34;http://twitter.com/nakkaya&#34;&gt;Twitter&lt;/a&gt;. His
&lt;a href=&#34;http://nakkaya.com/&#34;&gt;Blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My tip would be on destructuring, which allows you to pull apart data
structures into local bindings.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     (let [[x y] [1 2]] 
       x)
     ;;user=&amp;gt; 1

     (let [[a b c] &amp;quot;abc&amp;quot;] 
       c)
     ;;user=&amp;gt; \c

     (let [[[x1 y1][x2 y2]] [[1 2] [3 4]]]
       [x1 y1 x2 y2])
     ;;user=&amp;gt; [1 2 3 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Besides destructuring sequential things (vectors, lists, seqs, strings,
arrays, or anything that supports nth), you can destructure maps as
well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     (let [{key1 :key1 key2 :key2} {:key1 5 :key2 6}] 
       [key1 key2])
     ;;user=&amp;gt; [5 6]

     (let [{[x1 y1] :player1 [x2 y2] :player2} {:player1 [5 6] :player2 [9 9]}] 
       [x1 y1 x2 y2])
     ;;user=&amp;gt; [5 6 9 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most of the time, your local variables has the same names as the
keywords, Clojure provides a shortcut that saves you from typing binding
x keyword :x over and over again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     (let [{:keys [key1 key2]} {:key1 5 :key2 6}] 
            [key1 key2])
     ;;user=&amp;gt; [5 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more on destructuring, checkout the
&lt;a href=&#34;http://clojure.org/special_forms#Special%20Forms--(let[bindings*%20]%20exprs*&#34;&gt;documentation&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;ramakrishnan-muthukrishnan:8e2a8fa6113b13df9499ac52ecdd6e19&#34;&gt;Ramakrishnan Muthukrishnan&lt;/h2&gt;

&lt;p&gt;Find him on &lt;a href=&#34;http://twitter.com/vu3rdd&#34;&gt;Twitter&lt;/a&gt;. His &lt;a href=&#34;http://github.com/vu3rdd&#34;&gt;GitHub
Id&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tip #1&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;If you have a sequence and want to remove duplicates, there are
(atleast) two ways to do it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(vec (into #{} [1 2 2 3 4 5])) ; =&amp;gt; [1 2 3 4 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(distinct [1 2 2 3 4 5]) ; =&amp;gt; [1 2 3 4 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second one is preferred.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tip #2&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;In a function, if you have a list of parameters, you can do the
following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn foo [x &amp;amp; xs]
 (...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same can be done in anonymous functions too. What if you are using
the abbreviated form (reader macro form) of an anonymous function? You
can still use it by using the “%&amp;amp;” to denote the rest of the argument as
a list. One example of the use of this form is shown
&lt;a href=&#34;http://www.bestinclass.dk/index.clj/2009/10/brians-functional-brain.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tip #3&lt;/strong&gt;: I echo Craig Andera’s opinions on &lt;strong&gt;map&lt;/strong&gt;, &lt;strong&gt;filter&lt;/strong&gt; and
&lt;strong&gt;reduce&lt;/strong&gt;. It is extremely important to master these three constructs.
Especially, the way &lt;strong&gt;reduce&lt;/strong&gt; can be used with hash-maps.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tip #4&lt;/strong&gt;: If you want to have default values for some of the input
parameters, one way is to define functions of diferent arity.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(defn foo
 ([] (foo &amp;quot;bar&amp;quot;))
 ([s] (........)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, when ‘foo’ is called without any arguments, we assume a default
value of “bar”, a string as argument to the function and call foo with
that argument.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;stuart-sierra:8e2a8fa6113b13df9499ac52ecdd6e19&#34;&gt;Stuart Sierra&lt;/h2&gt;

&lt;p&gt;Find him on &lt;a href=&#34;http://twitter.com/stuartsierra&#34;&gt;Twitter&lt;/a&gt;. His
&lt;a href=&#34;http://stuartsierra.com/&#34;&gt;Blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Well, I’ve said this before, but it bears saying again: Don’t write a
macro where a function will do. Functions are more flexible: they can be
composed and passed as values. Do not use macros solely to make the
syntax “prettier.”&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Do you like these tips? We are eager to know your reactions as comments
to this post.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>&#34;AkitaOnRails&#34; On Ruby Symbols</title>
      <link>http://rubylearning.com/blog/2007/11/26/akitaonrails-on-ruby-symbols/</link>
      <pubDate>Mon, 26 Nov 2007 00:00:00 +0000</pubDate>
      
      <guid>http://rubylearning.com/blog/2007/11/26/akitaonrails-on-ruby-symbols/</guid>
      <description>&lt;p&gt;&lt;em&gt;RubyLearning recently caught with &lt;strong&gt;Fabio Akita&lt;/strong&gt; from Brazil and got
his viewpoint on one of the vexing areas for beginners in Ruby –
&lt;strong&gt;Symbols&lt;/strong&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.rubylearning.com/images/akita.jpg&#34; alt=&#34;Fabio
Akita&#34; title=&#34;Fabio Akita&#34; /&gt;
&lt;strong&gt;Fabio
Akita&lt;/strong&gt; is a Brazilian Rails enthusiast, also known online as
“AkitaOnRails”. He regularly write posts on his own
&lt;a href=&#34;http://www.akitaonrails.com/&#34;&gt;blog&lt;/a&gt; and had published the very first
book tailored for the Brazilian audience called “Repensando a Web com
Rails”. He is now a full-time Ruby on Rails developer working as Brazil
Rails Practice Manager for the Utah company Surgeworks LLC.&lt;/p&gt;

&lt;p&gt;Ruby is very similar to many other object oriented languages. You can
find similar constructs from non-dynamic languages as Java or C#. On
the other hand, to start grasping all the possibilities of Ruby one has
to invest some time learning what we call ‘Rubyisms’. One example is
something called a *symbol*.&lt;/p&gt;

&lt;p&gt;This is more obvious when you start learning Ruby through Rails. Much of
Rails power comes from the fact that it uses a lot of rubyisms. Let’s
see one example: (&lt;strong&gt;Note&lt;/strong&gt;: You may want to brush up on
&lt;a href=&#34;http://rubylearning.com/satishtalim/ruby_symbols.html&#34;&gt;Symbols&lt;/a&gt; and
&lt;a href=&#34;http://rubylearning.com/satishtalim/ruby_activerecord_and_mysql.html&#34;&gt;ActiveRecord&lt;/a&gt;
before going through the examples that follow.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span style=&amp;quot;color:blue&amp;quot;&amp;gt;class Transact &amp;lt; ActiveRecord::Base
  validates_presence_of :when
  validates_presence_of :category, :account
  validates_presence_of :value
  validates_numericality_of :value

  belongs_to :category
  belongs_to :account
end&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;‘class’ we understand, after all, the mainstream languages are
‘object-oriented’. But what are all those colons doing through all the
code? Those denote Symbols. More important, the colons represent
initializers of the class &lt;strong&gt;Symbol&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;This can be quite confusing considering that the normal way of
initializing an object is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span style=&amp;quot;color:blue&amp;quot;&amp;gt;Symbol.new&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The ‘&lt;strong&gt;new&lt;/strong&gt;‘ call asks for the standard ‘&lt;strong&gt;initialize&lt;/strong&gt;‘ method defined
within the class. Turns out that this method is private, the idea being
that all symbols should be instantiated with the colon notation.&lt;/p&gt;

&lt;p&gt;Symbols are used as identifiers. Some other languages could simply use
Strings instead of Symbols. In Ruby, it would become something like
this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span style=&amp;quot;color:blue&amp;quot;&amp;gt;class Transact &amp;lt; ActiveRecord::Base
  validates_presence_of &amp;quot;when&amp;quot;
  validates_presence_of &amp;quot;category&amp;quot;, &amp;quot;account&amp;quot;
  validates_presence_of &amp;quot;value&amp;quot;
  validates_numericality_of &amp;quot;value&amp;quot;

  belongs_to &amp;quot;category&amp;quot;
  belongs_to &amp;quot;account&amp;quot;
end&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not so visually different: we got rid of the colons and went back to the
comfortable quotation marks. They look the same but behave differently.
Like Symbols in Ruby, Strings also have a special constructor. Instead
of doing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span style=&amp;quot;color:blue&amp;quot;&amp;gt;String.new(&amp;quot;category&amp;quot;)&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We just do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span style=&amp;quot;color:blue&amp;quot;&amp;gt;&amp;quot;category&amp;quot;&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One could call these kind of shortcuts as “eye-candy”, but the languages
would be pretty harsh without them. We use Strings all the time, and it
would be extremely painful to instantiate new Strings without this
special constructor: simply writing it between quotation marks.&lt;/p&gt;

&lt;p&gt;The problem is, as Strings are easy to write, we overuse them more often
than not. There is an important side-effect: each new construct
instantiates a brand new object in memory, even though they have the
same content. For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span style=&amp;quot;color:blue&amp;quot;&amp;gt;&amp;gt;&amp;gt; &amp;quot;category&amp;quot;.object_id
=&amp;gt; 2953810

&amp;gt;&amp;gt; &amp;quot;category&amp;quot;.object_id
=&amp;gt; 2951340&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, we instantiate two strings with the same content. Each object in
memory has a unique ID so each string created above uses a separate
memory slot and have separate IDs. Now imagine that the same string
shows up in hundreds of different places throughout your project. You’re
definitely using more memory than necessary.&lt;/p&gt;

&lt;p&gt;But, this is not a new problem. For that, we have another construct in
most languages called ‘constants’, Ruby included. We have to
conscientiously plan and pre-define several constants beforehand. So,
that’s how our previous example would be using memory efficient
constants:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span style=&amp;quot;color:blue&amp;quot;&amp;gt;class Transact &amp;lt; ActiveRecord::Base
  ACCOUNT = &amp;quot;account&amp;quot;
  CATEGORY = &amp;quot;category&amp;quot;
  VALUE = &amp;quot;value&amp;quot;
  WHEN = &amp;quot;when&amp;quot;

  validates_presence_of WHEN
  validates_presence_of CATEGORY, ACCOUNT
  validates_presence_of VALUE
  validates_numericality_of VALUE

  belongs_to CATEGORY
  belongs_to ACCOUNT
end&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works, but this is not nearly as nice. First of all, you have to
pre-define everything beforehand, either in the same class or a
separated module just for constants. Second, the code is less elegant,
less readable, thus, less maintainable.&lt;/p&gt;

&lt;p&gt;So, we get back to the purpose of Symbols: being as memory efficient as
constants but as easy to the eyes as full fledged strings. Quotation
mark notation is already taken for Strings, capitalized words for
constants, dollar sign for global variables and so on. So, colon was a
good candidate.&lt;/p&gt;

&lt;p&gt;Let’s see what it all means:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span style=&amp;quot;color:blue&amp;quot;&amp;gt;&amp;gt;&amp;gt; &amp;quot;string&amp;quot;.object_id
=&amp;gt; 3001850
&amp;gt;&amp;gt; &amp;quot;string&amp;quot;.object_id
=&amp;gt; 2999540

&amp;gt;&amp;gt; :string.object_id
=&amp;gt; 69618
&amp;gt;&amp;gt; :string.object_id
=&amp;gt; 69618&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we explained before, the first two strings have the same content and
look similar, but they do occupy different memory slots, allowing for
unnecessary duplication.&lt;/p&gt;

&lt;p&gt;The last two symbols both are exactly the same thing. So I can call
identifiers as symbols through all my code without worrying about
duplication in memory. They are easy to initialize and easy to manage.&lt;/p&gt;

&lt;p&gt;We can also transform a String into a Symbol and vice-versa:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span style=&amp;quot;color:blue&amp;quot;&amp;gt;&amp;gt;&amp;gt; &amp;quot;string&amp;quot;.to_sym
=&amp;gt; :string
&amp;gt;&amp;gt; :symbol.to_s
=&amp;gt; &amp;quot;symbol&amp;quot;&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One good place where this is put to good use is within Rails’
&lt;strong&gt;ActiveSupport&lt;/strong&gt;. This package was made to extend the Ruby language,
and one such extension was made to the ubiquitous &lt;strong&gt;Hash&lt;/strong&gt; class. Let’s
see an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;span style=&amp;quot;color:blue&amp;quot;&amp;gt;&amp;gt;&amp;gt; params = { &amp;quot;id&amp;quot; =&amp;gt; 1, &amp;quot;action&amp;quot; =&amp;gt; &amp;quot;show&amp;quot; }
=&amp;gt; {&amp;quot;action&amp;quot;=&amp;gt;&amp;quot;show&amp;quot;, &amp;quot;id&amp;quot;=&amp;gt;1}

&amp;gt;&amp;gt; params[&amp;quot;id&amp;quot;]
=&amp;gt; 1

&amp;gt;&amp;gt; params.symbolize_keys!
=&amp;gt; {:id=&amp;gt;1, :action=&amp;gt;&amp;quot;show&amp;quot;}

&amp;gt;&amp;gt; params[:id]
=&amp;gt; 1&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first statement instantiates and populates a &lt;strong&gt;Hash&lt;/strong&gt; (yet another
special initialization notation). The second statement asks for the
value identified by the key “id”, which is a string.&lt;/p&gt;

&lt;p&gt;Instead of doing it this way, we can call the &lt;strong&gt;symbolize_keys!&lt;/strong&gt; to
transform all string keys into symbol keys. Now in the last statement we
can use the more usual Rails notation as symbol keys within a Hash. When
Rails receives a HTML Form post request, it only gets strings, so it is
its job to convert everything into meaningful Rails objects. If you’ve
been in the Rails world, you already saw this usage with controllers.&lt;/p&gt;

&lt;p&gt;So, this is all to be said about Symbols: very simple constructs that
makes code more readable and more efficient at the same time, which is
compatible with the Ruby Way.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you Fabio for showing us a different perspective on Symbols. In
case you have any queries, questions on this article, kindly post your
questions here and Fabio would be glad to answer.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Technorati Tags: &lt;a href=&#34;http://technorati.com/tag/Brazil&#34;&gt;Brazil&lt;/a&gt;, &lt;a href=&#34;http://technorati.com/tag/Fabio+Akita&#34;&gt;Fabio
Akita&lt;/a&gt;, &lt;a href=&#34;http://technorati.com/tag/Ruby+Programming&#34;&gt;Ruby
Programming&lt;/a&gt;, &lt;a href=&#34;http://technorati.com/tag/Ruby+Symbols&#34;&gt;Ruby
Symbols&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ruby Quirks</title>
      <link>http://rubylearning.com/blog/2007/04/11/ruby-quirks/</link>
      <pubDate>Wed, 11 Apr 2007 00:00:00 +0000</pubDate>
      
      <guid>http://rubylearning.com/blog/2007/04/11/ruby-quirks/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Ruby Quirks&lt;/strong&gt; – peculiarity of behavior? I know this topic is
debatable and remember &amp;ldquo;one man&amp;rsquo;s meat is another man&amp;rsquo;s poison!&amp;rdquo; I plan
to write down here (in no particular order), some of the little Ruby
quirks that I&amp;rsquo;ve picked up and which, I now use comfortably.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Peter Cooper, the author of the book ‘Beginning Ruby&amp;rsquo; introduced me to
Real-Time chat using an IRC client. On the #ruby channel at
irc://irc.freenode.net/ I heard of this quirk:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MotorCycle
  def initialize(make, color)
    @make, @color = make, color
  end
end

m = MotorCycle.new(&#39;Honda&#39;, &#39;blue&#39;)
m.instance_variable_set(:@make, &#39;Kawasaki&#39;)
m.instance_variable_set(:@gears, 4)
puts m.inspect
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check the output of the above program. In the code above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;m.instance_variable_set(:@gears, 4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sets the instance variable names by &lt;em&gt;symbol&lt;/em&gt; to &lt;em&gt;object&lt;/em&gt;, thereby
frustrating the efforts of the class&amp;rsquo;s author to attempt to provide
proper encapsulation. The variable did not have to exist prior to this
call. &lt;strong&gt;Update:&lt;/strong&gt; Hal Fulton in his excellent book ‘The Ruby Way&amp;rsquo;
has this to say about &lt;code&gt;instance_variable_set&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s true these methods are powerful and potentially dangerous. They should
be used cautiously, not casually. But it&amp;rsquo;s impossible to say whether
encapsulation is violated without looking at *how these tools are used*.
If they are used intentionally as part of a good design, then all is well.
If they are used to violate the design, or to circumvent a bad design, then
all is not well.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This one is not really a quirk but appears to be one, especially for people
coming from a Java background. Last year, [Shashank Date][1] gave the
[PuneRuby][2] members a presentation on ‘Why Ruby Shines&amp;rsquo; and three points
stood out –&lt;/p&gt;

&lt;p&gt;&amp;lsquo;Expressions everywhere&amp;rsquo;, ‘Active Class Definitions&amp;rsquo; and ‘Everything is
an Object&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Expressions everywhere&lt;/em&gt;&lt;/strong&gt; – In Ruby, everything
returns some value. Therefore a class definition is an expression and
one can say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c = class C
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The value of c is nil.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Active Class Definitions&lt;/em&gt;&lt;/strong&gt; – Look at
the following program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class C
  puts &#39;In class C&#39;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When this class is read the first time, it executes puts and the output
is – ‘In class C&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Everything is an Object&lt;/em&gt;&lt;/strong&gt; – After being with Java since 1995, the concept
that classes in Ruby are first-class objects, is hard to digest at first – each
is an instance of class Class. When a new class is defined (typically using
class Name … end), an object of type Class is created and assigned to a
constant (Name. in this case). Hal Fulton&amp;rsquo;s suggests a &lt;em&gt;mantra&lt;/em&gt; to be recited
everyday – &amp;ldquo;Class &lt;em&gt;is an object&lt;/em&gt;, and Object &lt;em&gt;is a class&lt;/em&gt;.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If I want to swap two variables, I would normally use an additional temporary
variable.&lt;/p&gt;

&lt;p&gt;In Ruby, this is not necessary:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x, y = y, x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will interchange the values of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Jaaron, a reader of
this Learning Ruby Blog has this quirk for us. This one is well known
and is the cause of much frustration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = 7
[1,2,3].each do |x|
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the name of a block parameter conflicts with the name of a local
variable, the behavior is to assign the local variable to the argument.
In this case, the local variable x gets assigned the value 1, then the
value 2, then the value 3. The value 7 is lost.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update (13th April):&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Matt Chen, Matthew King and Ara Vartanian have commented on this behavior. If
you refer to Programming Ruby Second Edition eBook (page 100) it says:&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;The whole issue with variable scope and blocks is one that generates
considerable discussion in the Ruby community. The current scheme has
definite problems (particularly when variables are unexpectedly aliased
inside blocks), but at the same time no one has managed to come up with
something thats both better and acceptable to the wider community. Matz is
promising changes in Ruby 2.0.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Are instance variables inherited by a sub-class? David Black the author
of Ruby for Rails has this to say: Instance variables are per-object,
not per-class, and they&amp;rsquo;re not inherited. But if a method uses one, and
that method is available to subclasses, then it will still use the
variable — but “the variable” in the sense of one per object. See the
following program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class C
  def initialize
    @n = 100
  end

  def increase_n
    @n *= 20
  end
end

class D &amp;lt; C
  def show_n
    puts &amp;quot;n is #{@n}&amp;quot;
  end
end

d = D.new
d.increase_n
d.show_n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;ruby p049instvarinherit.rb
n is 2000
&amp;gt;Exit code: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;6&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Morgan Schweers, a reader of this blog has this quirk for us.&lt;/p&gt;

&lt;p&gt;Imagine for a moment, that you want to be able to set a variable, but if
it&amp;rsquo;s not set, you default to a known value. You&amp;rsquo;d rather do it on a
single line. One of my co-workers tried this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expand = defined?( expand ) ? expand : true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but &lt;code&gt;expand&lt;/code&gt; is &lt;em&gt;defined&lt;/em&gt; by being on the left hand side, BEFORE
the RHS is evaluated, so &lt;code&gt;defined?&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, but because expand
hasn&amp;rsquo;t got a value yet, it returns nil. I tried:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expand = true unless defined?(expand)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and it doesn&amp;rsquo;t help either, which really shocked me.&lt;/p&gt;

&lt;p&gt;I always believed that the postfix-conditional was evaluated before even
beginning to evaluate the operation, but I was distinctly disabused of this
notion by testing. Note that ‘expand?&amp;rdquo; operator returns nil if its argument
(which can be an arbitrary expression) is not defined; otherwise it returns a
description of that argument. I don&amp;rsquo;t understand the reason for the behavior,
and I think it&amp;rsquo;s a bug, but I&amp;rsquo;d love to know a good language reason for it.&lt;/p&gt;

&lt;p&gt;I am sure that you would have noticed many other &lt;strong&gt;Ruby Quirks&lt;/strong&gt;. I&amp;rsquo;d
definitely like to hear and add them here.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Information&lt;/strong&gt; Ruby is an open source thorough language of
utmost balance with combination of Perl, Smalltalk, Lisp, Ada and
Eiffel. With the recent developments in this language, most developers
use this language in the middle tier. Today is the era of developing
online business applications, [mobile software][3]: and its applications.
Most developers deploy their online applications after getting [business
web hosting][4] and then they market for these projects through
[affiliate marketing][5] campaigns or if they do not want to sell their
project they can use [ppc advertising][6] for earning some revenue or
can offer [ppc management][7] programs. When they are in the process of
development usually they [register domain][8] and use [domain
parking][9] facility, so that once their project is ready they can
instantly put it on the internet.&lt;/p&gt;

&lt;p&gt;Technorati Tags:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://technorati.com/tag/Ruby+Quirks&#34;&gt;Ruby Quirks&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[1]: &lt;a href=&#34;http://rubylearning.com/blog/2007/04/11/interview-shashank-date/&#34;&gt;http://rubylearning.com/blog/2007/04/11/interview-shashank-date/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[2]: &lt;a href=&#34;http://tech.groups.yahoo.com/group/puneruby/&#34;&gt;http://tech.groups.yahoo.com/group/puneruby/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[3]: &lt;a href=&#34;http://www.mysoftwarehubs.com&#34;&gt;http://www.mysoftwarehubs.com&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[4]: &lt;a href=&#34;http://www.envisionwebhosting.com&#34;&gt;http://www.envisionwebhosting.com&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[5]: &lt;a href=&#34;http://www.getaffiliates.net&#34;&gt;http://www.getaffiliates.net&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[6]: &lt;a href=&#34;http://www.qualifytraffic.com/Advertising-Info/PPC-Advertising.html&#34;&gt;http://www.qualifytraffic.com/Advertising-Info/PPC-Advertising.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[7]: &lt;a href=&#34;http://www.performanceppc.com&#34;&gt;http://www.performanceppc.com&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[8]: &lt;a href=&#34;http://www.namingwiz.com&#34;&gt;http://www.namingwiz.com&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[9]: &lt;a href=&#34;http://www.nationaldomainreg.com/Domain-Parking.html&#34;&gt;http://www.nationaldomainreg.com/Domain-Parking.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Your favourite bit of Ruby code?</title>
      <link>http://rubylearning.com/blog/2007/02/09/your-favourite-bit-of-ruby-code/</link>
      <pubDate>Fri, 09 Feb 2007 00:00:00 +0000</pubDate>
      
      <guid>http://rubylearning.com/blog/2007/02/09/your-favourite-bit-of-ruby-code/</guid>
      <description>&lt;p&gt;An interesting thread at Ruby_talk is &amp;lsquo;Your favorite bit of Ruby code.&amp;rsquo;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Setting aside time for &lt;a href=&#34;http://www.socialstudieshelp.com/topics/learning-html.html&#34;&gt;learning
HTML&lt;/a&gt; is
beneficial to any web host.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;mailto:john.carter@tait.co.nz&#34;&gt;John Carter&lt;/a&gt; from New Zealand has this
interesting snippet of code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Ruby is Objects all the way down and open for extension...
class Integer
  def factorial
    return 1 if self &amp;lt;= 1
    self * (self-1).factorial
  end
end

puts 6.factorial
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Technorati Tags: &lt;a href=&#34;http://technorati.com/tag/Ruby+code&#34;&gt;Ruby code&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Convert bytes to megabytes</title>
      <link>http://rubylearning.com/blog/2007/02/06/convert-bytes-to-megabytes/</link>
      <pubDate>Tue, 06 Feb 2007 00:00:00 +0000</pubDate>
      
      <guid>http://rubylearning.com/blog/2007/02/06/convert-bytes-to-megabytes/</guid>
      <description>&lt;p&gt;In one of my projects, I need to find the file-size in megabytes again
and again. This simple method helps me to convert the size of a file in
bytes to megabytes. This is useful for very large files.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MEGABYTE = 1024.0 * 1024.0
def bytesToMeg bytes
  bytes /  MEGABYTE
end

# big file
len = File.size(&amp;quot;Dreamweaver8-en.exe&amp;quot;)
puts len.to_s + &#39; bytes&#39;  # displays 62651176 bytes
puts bytesToMeg(len).to_s + &#39; MB&#39;  # displays 59.7488174438477 MB
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;One of the uses for PDF conversion is
that by going through the process of &lt;a href=&#34;http://www.oardc.ohio-state.edu/library/word_to_pdf.html&#34;&gt;converting PDF to
Word&lt;/a&gt; you’ll have a more easily editable document than if you didn’t do
PDF conversion and tried to edit
a PDF file.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The program code is pretty obvious and as you can see the method uses
division. However, it is best to wrap this functionality in a method.&lt;/p&gt;

&lt;p&gt;Technorati Tags: &lt;a href=&#34;http://technorati.com/tag/Convert+bytes+to+megabytes&#34;&gt;Convert bytes to
megabytes&lt;/a&gt;, &lt;a href=&#34;http://technorati.com/tag/Ruby+tricks&#34;&gt;Ruby
tricks&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
